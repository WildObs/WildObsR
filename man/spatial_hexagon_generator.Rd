% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spatial_hexagon_generator.R
\name{spatial_hexagon_generator}
\alias{spatial_hexagon_generator}
\title{Generate spatially distinct sampling units}
\usage{
spatial_hexagon_generator(data, scales)
}
\arguments{
\item{data}{A dataframe of covariates that includes, at minimum, the following columns:
\code{deploymentID}, \code{locationName}, \code{deploymentGroups}, \code{source}, \code{latitude}, and \code{longitude}.
These fields are part of WildObs camtrapDP-formatted Frictionless Data Packages.}

\item{scales}{A numeric vector specifying the \strong{areas of hexagonal grid cells in square meters (m²)}.
Values smaller than 1e6 (1 km²) are allowed. The function automatically labels each scale
as either m² or km² for readability.}
}
\value{
A dataframe containing the original input data plus:
\itemize{
\item One column per scale named \verb{polygon_<scale>} (spatial hexagon ID).
\item One column per scale named \verb{cellID_<scale>} (spatial + temporal hexagon ID).
}
}
\description{
This function generates spatially distinct hexagonal sampling units to group nearby
camera trap deployments. It ensures that sampling units are spatially and temporally
independent across multiple contributors and surveys.
}
\details{
The function overlays one or more hexagonal grids at user-specified \emph{spatial scales}
and assigns each camera deployment (\code{deploymentID}) to its corresponding hexagonal cell.
Each scale value defines the \strong{area} of a single hexagon (not its edge length), expressed
in \strong{square meters (m²)}. Internally, these area values are converted into the corresponding
apothem distance (distance from the hexagon's center to the midpoint of a side) using the
geometric relationship:

\deqn{A = \frac{3 \sqrt{3}}{2} s^2}
\deqn{a = \frac{\sqrt{3}}{2} s}

where \emph{A} is the hexagon area, \emph{s} is the side length, and \emph{a} is the apothem (used to
set the grid spacing). This means:
\itemize{
\item A value of \strong{1000000} (1e6) corresponds to hexagons with an area of \strong{1 km²}.
\item A value of \strong{25000000} (25e6) corresponds to hexagons with an area of \strong{25 km²}.
\item Smaller values (e.g., 100,000 = 0.1 km²) produce finer grids.
}

Each deployment is assigned two identifiers per scale:
\describe{
\item{\verb{polygon_<scale>}}{Spatially distinct hexagon cell ID (independent of time).}
\item{\verb{cellID_<scale>}}{Spatially and temporally distinct hexagon cell ID, incorporating survey year and data source}
}

If multiple data sources sample the same hexagon in overlapping time windows, their
deployments are grouped and flagged with a combined contributor code.
}
\examples{
# Create example camera-trap metadata
\donttest{
set.seed(42)

# Simulate 12 camera deployments across 3 sites and 2 contributors
data <- tibble::tibble(
  deploymentID = paste0("cam_", 1:12),
  locationName = rep(c("Site_A", "Site_B", "Site_C"), each = 4),
  source = rep(c("UQ_team", "CSIRO_team"), length.out = 12),

  # Cluster each site around distinct centers (approx Wet Tropics, QLD)
  latitude = c(
    rnorm(4, mean = -17.10, sd = 0.01),   # Site_A: tight cluster
    rnorm(4, mean = -17.25, sd = 0.005),  # Site_B: tighter cluster
    rnorm(4, mean = -16.95, sd = 0.03)    # Site_C: more spread out
  ),
  longitude = c(
    rnorm(4, mean = 145.65, sd = 0.01),   # Site_A
    rnorm(4, mean = 145.50, sd = 0.005),  # Site_B
    rnorm(4, mean = 145.75, sd = 0.03)    # Site_C
  ),

  # Random deployment dates over two months
  deploymentStart = as.POSIXct("2023-07-01") + runif(12, 0, 30) * 86400,
  deploymentEnd   = as.POSIXct("2023-09-01") + runif(12, 0, 30) * 86400
)

# Simulate a column that identifies unique survey events
data$deploymentGroups <- paste0(data$locationName, "_", format(data$deploymentStart, "\%Y"))

# --- Define grid scales ---
# The values represent hexagon *areas* in square meters.
# 1e6 = 1 km² hexagons; 25e6 = 25 km² hexagons.
scales <- c(1e6, 25e6)

# --- Generate hexagonal sampling units ---
hex_data <- spatial_hexagon_generator(data, scales)

# Inspect new columns (polygon_ and cellID_ per scale)
dplyr::select(hex_data, deploymentID, starts_with("polygon"), starts_with("cellID")) \%>\%
  head()
}

}
\author{
Zachary Amir
}
